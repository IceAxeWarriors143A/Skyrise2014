#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    arm_p,          sensorPotentiometer)
#pragma config(Sensor, in2,    wrist_p,        sensorNone)
#pragma config(Sensor, dgtl1,  RackLimit,      sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           rightDrive,    tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port2,           claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           rightClawPivot, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           leftClawPivot, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           rightArmPivot, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           leftArmPivot,  tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           rightRackLift, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           leftRackLift,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           middleDrive,   tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port10,          leftDrive,     tmotorVex393_HBridge, openLoop, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Platform config
#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(OFF) //OFF or Competition
#pragma autonomousDuration(0)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"

//1 = Henry
//2 = Adira
//3 = Brynne
//4 = Michael
//5 = Garrison
//6 = Jim
int driver = 6;

//1 = turn around, raise arm and rack to 50%
//2 = raise rack 50%, strafe right, turn 100 degrees, raise rack fully, open claw
int auto = 1;

bool bRackLiftDown;
bool bRackLiftUp;

bool bArmPivotUp;
bool bArmPivotDown;

bool bClawOpen;
bool bClawClose;

bool bClawPivotUp;
bool bClawPivotDown;

// Twp joystick tank drive control
void tank_drive(float middle, float x, float y)
{
	if(abs(x) > 30 && abs(y) > 10)
	{
		motor[rightDrive] = (y - x) / 2;
		motor[leftDrive] = (y + x) / 2;
	}
	else if (abs(y) > 10)
	{
		motor[rightDrive] = y;
		motor[leftDrive] = y;
	}
	else
	{
		motor[rightDrive] = 0;
		motor[leftDrive] = 0;
	}

	if(abs(middle) > 5)
	{
		motor[middleDrive] = middle;
	}
	else
	{
		motor[middleDrive] = 0;
	}
}

//Two joystick h-drive control
void h_drive(float xLeftStick, float yLeftStick, float xRightStick, float yRightStick)
{
	if(abs(yRightStick) > 10)
	{
		//Directional Movement
		motor[rightDrive] = yRightStick;
		motor[leftDrive] = yRightStick;
	}
	else if(abs(xLeftStick) > 10)
	{
		//Turning
		motor[rightDrive] = -xLeftStick;
		motor[leftDrive] = xLeftStick;
	}
	else
	{
		motor[rightDrive] = 0;
		motor[leftDrive] = 0;
	}

	//Middle
	if(abs(xRightStick) > 5)
	{
		motor[middleDrive] = xRightStick;
	}
	else
	{
		motor[middleDrive] = 0;
	}

}
// Lift for the claw arm
void drive_rack_lift(int speed)
{
	motor[rightRackLift] = speed;
	motor[leftRackLift] = -speed;
}

// Drive the lift down
void rack_lift_down(int speed)
{
	if(!SensorValue[RackLimit]==1)
	{
		drive_rack_lift(speed);
	}
	else
	{
		drive_rack_lift(0);
	}
}

// Drive the lift up
void rack_lift_up()
{
	drive_rack_lift(127);
}

// Stop the lift
void rack_lift_stop()
{
	drive_rack_lift(0);
}

void arm_pivot_drive(int speed)
{
	motor[rightArmPivot] = speed;
	motor[leftArmPivot] = speed;
}

void arm_pivot_up()
{
	arm_pivot_drive(64);
}

void arm_pivot_down()
{
	arm_pivot_drive(-64);
}

void arm_pivot_stop()
{
	arm_pivot_drive(0);
}

void claw_drive(int speed)
{
	motor[claw] = speed;
}

void claw_open()
{
	claw_drive(64);
}

void claw_close()
{
	claw_drive(-64);
}

void claw_stop()
{
	claw_drive(0);
}

void claw_pivot_up()
{
	motor[rightClawPivot] = 60;
	motor[leftClawPivot] = 60;
}

void claw_pivot_down()
{
	motor[rightClawPivot] = -60;
	motor[leftClawPivot] = -60;
}

void claw_pivot_stop()
{
	motor[rightClawPivot] = 0;
	motor[leftClawPivot] = 0;
}

void drive(int value, bool equal)
{
	if(!equal)
	{
		motor[leftDrive] = value;
		motor[rightDrive] = value;
	}
	if(equal)
	{
		if(nMotorEncoder[leftDrive] < nMotorEncoder[rightDrive])
		{
			motor[leftDrive] = value;
			motor[rightDrive] = 0.75 * value;
		}
		if(nMotorEncoder[leftDrive] > nMotorEncoder[rightDrive])
		{
			motor[leftDrive] = 0.75 * value;
			motor[rightDrive] = value;
		}
		if(nMotorEncoder[leftDrive] == nMotorEncoder[rightDrive])
		{
			motor[leftDrive] = value;
			motor[rightDrive] = value;
		}
	}
}

void turn(int value)
{
	motor[leftDrive] = value;
	motor[rightDrive] = -value;
}

// All init functions and definitions go in here
void pre_auton()
{
}

// All functions for fully autonomous control of robot go here
task autonomous()
{
	motor[rightDrive] = 0;
	motor[leftDrive] = 0;
	motor[middleDrive] = 0;
	nMotorEncoder[rightDrive] = 0;
	nMotorEncoder[leftDrive] = 0;
  nMotorEncoder[leftRackLift] = 0;
  nMotorEncoder[middleDrive] = 0;
  //one inch = 50 counts
  //one foot = 600 counts
  
  //3.86 counts per degree
  //347 counts per 90 degrees 
  
	/*if(auto == 1)
	{
		//Raise rack to 250 counts
		while(nMotorEncoder[leftRackLift] <= 250)
		{
			drive_rack_lift(127);
		}
		drive_rack_lift(0);
		//Drive forward 500 counts
		while(nMotorEncoder[leftDrive] < 500)
		{
			drive(127, true);
		}
		drive(0, false);
		//Turn 90 degrees clockwise
		while(nMotorEncoder[leftDrive] < 500)
		{
			turn(127);	
		}
		drive(0, false);
		//Drive forward y distance
		while(nMotorEncoder[leftDrive] < DISTANCE)
		{
			drive(127, true);
		}
		drive(0, false);
		//Turn 90 degrees counter clockwise
		while(nMotorEncoder[rightDrive] < 500)
		{
			turn(-127);	
		}
		drive(0, false);
		//Raise arm z distance
		while(sensorValue[arm_p] < (3.86 * NUMBER_OF_DEGREES))
		{
			motor[leftArmPivot] = 127;
			motor[rightArmPivot] = 127;
		}
		motor[leftArmPivot] = 0;
		motor[rightArmPivot] = 0;
		//Drive forward 500 counts
		while(nMotorEncoder[leftDrive] < 500)
		{
			drive(127, true);
		}
		drive(0, false);
		//Open claw
		motor[claw] = 127;
		wait1Msec(100);
		motor[claw] = 0;
	}
	/*else if(auto == 2)
	{
		//Raise rack 250 counts
		//Strafe right
		//Turn 100 degrees clockwise
		//Raise rack to 550 counts
		//Open claw
	}*/
}

// All functions for joystick-operated mode go here
task usercontrol()
{
	int arm_pent = 0;
	motor[rightDrive] = 0;
	motor[leftDrive] = 0;
	motor[middleDrive] = 0;
	while(true)
	{
		int xRightStick = vexRT[Ch1];
		int yRightStick = vexRT[Ch2];
		int xLeftStick = vexRT[Ch4];
		int yLeftStick = vexRT[Ch3];

		if(driver == 1)
		{
			bRackLiftDown = vexRT[Btn7D];
			bRackLiftUp = vexRT[Btn7U];

			bArmPivotUp = vexRT[Btn5U];
			bArmPivotDown = vexRT[Btn5D];

			bClawOpen = vexRT[Btn8R];
			bClawClose = vexRT[Btn8L];

			bClawPivotUp = vexRT[Btn8U];
			bClawPivotDown = vexRT[Btn8D];
			tank_drive(xLeftStick, xRightStick, yRightStick);
		}
		else if(driver == 2)
		{
			bRackLiftDown = vexRT[Btn7D];
			bRackLiftUp = vexRT[Btn7U];

			bArmPivotUp = vexRT[Btn7R];
			bArmPivotDown = vexRT[Btn7L];

			bClawOpen = vexRT[Btn8R];
			bClawClose = vexRT[Btn8L];

			bClawPivotUp = vexRT[Btn8U];
			bClawPivotDown = vexRT[Btn8D];
			tank_drive(yLeftStick, xRightStick, yRightStick);
		}
		else if(driver == 3)
		{
			bRackLiftDown = vexRT[Btn6D];
			bRackLiftUp = vexRT[Btn6U];

			bArmPivotUp = vexRT[Btn5U];
			bArmPivotDown = vexRT[Btn5D];

			bClawOpen = vexRT[Btn7R];
			bClawClose = vexRT[Btn7L];

			bClawPivotUp = vexRT[Btn7U];
			bClawPivotDown = vexRT[Btn7D];
			tank_drive(xLeftStick, xRightStick, yRightStick);
		}
		else if(driver == 4)
		{
			bRackLiftDown = vexRT[Btn5D];
			bRackLiftUp = vexRT[Btn5U];

			bArmPivotUp = vexRT[Btn6U];
			bArmPivotDown = vexRT[Btn6D];

			bClawOpen = vexRT[Btn8L];
			bClawClose = vexRT[Btn8R];

			bClawPivotUp = vexRT[Btn8U];
			bClawPivotDown = vexRT[Btn8D];
			tank_drive(xRightStick, xLeftStick, yLeftStick);
		}
		else if(driver == 5)
		{
			bRackLiftDown = vexRT[Btn7D];
			bRackLiftUp = vexRT[Btn7U];

			bArmPivotUp = vexRT[Btn5U];
			bArmPivotDown = vexRT[Btn5D];

			bClawOpen = vexRT[Btn8R];
			bClawClose = vexRT[Btn8L];

			bClawPivotUp = vexRT[Btn8U];
			bClawPivotDown = vexRT[Btn8D];
			h_drive(xLeftStick, yLeftStick, xRightStick, yRightStick);
		}
		else if(driver == 6)
		{
			bRackLiftDown = vexRT[Btn7D];
			bRackLiftUp = vexRT[Btn7U];

			bArmPivotUp = vexRT[Btn5U];
			bArmPivotDown = vexRT[Btn5D];

			bClawOpen = vexRT[Btn8R];
			bClawClose = vexRT[Btn8L];

			bClawPivotUp = vexRT[Btn8U];
			bClawPivotDown = vexRT[Btn8D];
			tank_drive(xLeftStick, xRightStick, yRightStick);
		}

		if(bRackLiftUp)
			rack_lift_up();
		else if(bRackLiftDown)
			rack_lift_down(-127);
		else if(bArmPivotUp)
			arm_pent = arm_pent + 1;
		else if(bArmPivotDown)
			arm_pent = arm_pent + 1;
		else if(bClawOpen)
			claw_open();
		else if(bClawClose)
			claw_close();
		else if(bClawPivotUp)
			claw_pivot_up();
		else if(bClawPivotDown)
			claw_pivot_down();

		if(!bRackLiftUp && !bRackLiftDown)
			rack_lift_stop();

		if(!bArmPivotUp && !bArmPivotDown)
			arm_pivot_stop();

		if(!bClawOpen && !bClawClose)
			claw_stop();

		if(!bClawPivotUp && !bClawPivotDown)
			claw_pivot_stop();
	
		if(sensorValue[arm_p] < arm_pent)
		{
			arm_pivot_up();
		}
		if(sensorValue[arm_p] > arm_pent)
		{
			arm_pivot_down();
		}
	}
}
